<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Imaginarium Galaxy</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; width:100%; height:100%; background:#000; }
    #galaxyCanvas { position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:0; }
    #thoughtContainer { position:absolute; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:1; }
    @keyframes popIn { 0%{transform:scale(0.2);opacity:0;}60%{transform:scale(1.4);opacity:1;}100%{transform:scale(1);opacity:1;} }
    .thought { position:absolute; padding:0.8em 1.2em; background:rgba(255,255,255,0.9); border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,0.15); transition:background-color 0.5s ease; cursor:pointer;
      user-select:none; opacity:0; transform:scale(0.2); font-size:1.2rem; max-width:90vw; width:fit-content;
      word-wrap:break-word; visibility:hidden; pointer-events:auto; }
    .thought.pop { visibility:visible; animation:popIn 0.6s ease forwards; }
    .thought:hover { transform:scale(1.2) rotate(2deg); background-color:#d0f0ff; }
    @media (max-width:768px) { .thought{font-size:1rem;padding:0.6em 1em;} }
    @media (max-width:480px) { .thought{font-size:0.9rem;padding:0.5em 0.8em;} }
  </style>
</head>
<body>
  <canvas id="galaxyCanvas"></canvas>
  <div id="thoughtContainer"></div>

  <!-- Three.js core + postprocessing -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script>
    // === Three.js Galaxy with finer sentiment-based bloom & darker greens ===
    const canvas = document.getElementById('galaxyCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 50);
    camera.lookAt(scene.position);

    // Bloom setup (initial thresholds adjusted for softer bloom)
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8,  
      0.2,
      0.15
    );
    composer.addPass(bloomPass);

    // Galaxy parameters
    const params = { count:20000, size:0.7, radius:180, branches:8, spin:1, randomness:0.6, ySpread:100, baseSpeed:0.00008, maxSpeed:0.0005 };
    let currentSpeed = params.baseSpeed;

    // Geometry and buffers
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(params.count * 3);
    const colors = new Float32Array(params.count * 3);
    const radii = new Float32Array(params.count);
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

    // Pre-calc positions
    for (let i = 0; i < params.count; i++) {
      const i3 = i * 3;
      const r = Math.random() * params.radius;
      radii[i] = r;
      const branch = (i % params.branches)/params.branches * Math.PI*2;
      const ang = branch + r * params.spin;
      positions[i3]     = Math.cos(ang)*r + (Math.random()-0.5)*params.randomness*r;
      positions[i3 + 1] = (Math.random()-0.5)*params.randomness*params.ySpread;
      positions[i3 + 2] = Math.sin(ang)*r + (Math.random()-0.5)*params.randomness*r;
      colors.set([0.5,0.5,0.5], i3);
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors,3));

    const material = new THREE.PointsMaterial({
      size: params.size,
      map: sprite,
      vertexColors: true,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const galaxy = new THREE.Points(geometry, material);
    scene.add(galaxy);

    // Update based on sentiment
    async function updateGalaxy() {
      try {
        const res = await fetch('/api/sentiment-avg');
        const { avg } = await res.json();
        const c = Math.max(-1, Math.min(2, avg));
        const vibrancy = (c + 1) / 3;

        // Speed
        currentSpeed = params.baseSpeed + vibrancy * (params.maxSpeed - params.baseSpeed);

        // Bloom weaker overall
        bloomPass.strength = vibrancy * 1.2;  // max ~1.2

        // Hue mapping, with darker greens
        const v = Math.max(-1, Math.min(1, avg));
        const baseHue = (v + 1) * 60 / 360;
        const colArr = geometry.attributes.color.array;

        for (let i = 0; i < params.count; i++) {
          const i3 = i * 3;
          const t = radii[i] / params.radius;
          // Slight hue variation
          const hue = baseHue + (Math.random() - 0.5) * 0.03;
          // Darker green gradient: lower max saturation/lightness
          const sat = 0.2 + vibrancy * 0.6 * (1 - t);
          const light = 0.2 + vibrancy * 0.4 * (1 - t);
          const col = new THREE.Color().setHSL(hue, sat, light);
          colArr[i3]     = col.r;
          colArr[i3 + 1] = col.g;
          colArr[i3 + 2] = col.b;
        }
        geometry.attributes.color.needsUpdate = true;
      } catch (e) {
        console.error('Galaxy update failed', e);
      }
    }

    // Animation
    function animate() {
      galaxy.rotation.y += currentSpeed;
      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Kick off updates
    updateGalaxy();
    setInterval(updateGalaxy, 2000);

    // === Thoughts Logic (unchanged) ===
    const container = document.getElementById('thoughtContainer');
    const thoughts = new Map();
    const clamp = (v, min, max) => v < min ? min : v > max ? max : v;

    async function loadThoughts() {
      const res = await fetch('/api/thoughts'); const data = await res.json();
      data.forEach(t => {
        if (thoughts.has(t.id)) return;
        const el = document.createElement('div'); el.className='thought'; el.textContent=t.content;
        container.appendChild(el);
        const {width:w,height:h} = el.getBoundingClientRect();
        const maxX=window.innerWidth-w, maxY=window.innerHeight-h;
        let pos={x:Math.random()*maxX, y:Math.random()*maxY};
        const saved = localStorage.getItem(`thought-${t.id}`);
        if (saved) { const p=JSON.parse(saved); pos.x=clamp(p.x,0,maxX); pos.y=clamp(p.y,0,maxY); }
        localStorage.setItem(`thought-${t.id}`, JSON.stringify(pos));
        Object.assign(el.style,{left:`${pos.x}px`,top:`${pos.y}px`});
        setTimeout(()=>el.classList.add('pop'),50);
        thoughts.set(t.id,{el,x:pos.x,y:pos.y,dx:(Math.random()-0.5)*1.5,dy:(Math.random()-0.5)*1.5,width:w,height:h});
      });
    }
    function animateThoughts() {
      thoughts.forEach((t,id) => {
        t.x += t.dx; t.y += t.dy;
        const maxX=window.innerWidth-t.width, maxY=window.innerHeight-t.height;
        if (t.x<=0||t.x>=maxX) { t.dx*=-1; t.x=clamp(t.x,0,maxX); }
        if (t.y<=0||t.y>=maxY) { t.dy*=-1; t.y=clamp(t.y,0,maxY); }
        Object.assign(t.el.style,{left:`${t.x}px`,top:`${t.y}px`});
        localStorage.setItem(`thought-${id}`, JSON.stringify({x:t.x,y:t.y}));
      });
      requestAnimationFrame(animateThoughts);
    }
    loadThoughts().then(()=>animateThoughts());
    setInterval(loadThoughts,10000);
  </script>
</body>
</html>
